use reqwest::Client;
use serde::Serialize;
use regex::Regex;

#[derive(Serialize)]
struct Comment {
    body: String,
}

/// Extracts numbers from a given PR description string.
pub fn extract_numbers(pr_description: &str) -> Vec<u32> {
    let re = Regex::new(r"\b\d+\b").unwrap();
    re.find_iter(pr_description)
        .filter_map(|digits| digits.as_str().parse::<u32>().ok())
        .collect()
}

/// Computes Fibonacci numbers up to a given threshold.
pub fn compute_fibonacci(n: u32) -> Vec<u32> {
    let mut fib = vec![0, 1];
    while let Some(&last) = fib.last() {
        let second_last = fib.get(fib.len() - 2).unwrap_or(&0);
        let next = last + second_last;
        if next > n {
            break;
        }
        fib.push(next);
    }
    fib
}

/// Processes a PR description, extracts numbers, and finds Fibonacci numbers within the range.
pub fn process_pr_description(pr_description: &str, max_threshold: u32) -> (Vec<u32>, Vec<u32>) {
    let numbers = extract_numbers(pr_description);
    let fib_sequence = compute_fibonacci(max_threshold);
    
    let fibonacci_numbers: Vec<u32> = numbers
        .iter()
        .filter(|num| fib_sequence.contains(num))
        .cloned()
        .collect();
    
    let non_fibonacci_numbers: Vec<u32> = numbers
        .iter()
        .filter(|num| !fib_sequence.contains(num))
        .cloned()
        .collect();
    
    (fibonacci_numbers, non_fibonacci_numbers)
}

/// Format a comment with Fibonacci analysis results
pub fn format_comment(
    fibonacci_numbers: &[u32], 
    non_fibonacci_numbers: &[u32], 
    all_numbers: &[u32], 
    threshold: u32
) -> String {
    let fib_sequence = compute_fibonacci(threshold);
    
    let mut comment = String::new();
    
    // Header with emoji
    comment.push_str("## üî¢ FibBot Analysis Results üßÆ\n\n");
    
    // Summary section
    comment.push_str("### Summary\n");
    comment.push_str(&format!("- üîç Found **{}** numbers in this PR\n", all_numbers.len()));
    comment.push_str(&format!("- ‚úÖ **{}** of these are Fibonacci numbers\n", fibonacci_numbers.len()));
    comment.push_str(&format!("- ‚ùå **{}** are not Fibonacci numbers\n", non_fibonacci_numbers.len()));
    comment.push_str(&format!("- üîù Max threshold set to: **{}**\n\n", threshold));
    
    // Fibonacci numbers section
    comment.push_str("### Fibonacci Numbers Found\n");
    if fibonacci_numbers.is_empty() {
        comment.push_str("No Fibonacci numbers found in this PR.\n\n");
    } else {
        comment.push_str("| Number | Fibonacci Index | Next in Sequence |\n");
        comment.push_str("|--------|----------------|------------------|\n");
        
        for &num in fibonacci_numbers {
            let index = fib_sequence.iter().position(|&x| x == num).unwrap_or(0);
            let next = if index + 1 < fib_sequence.len() {
                fib_sequence[index + 1]
            } else {
                0
            };
            
            comment.push_str(&format!("| {} | {} | {} |\n", num, index, next));
        }
        comment.push_str("\n");
    }
    
    // Non-Fibonacci numbers section
    if !non_fibonacci_numbers.is_empty() {
        comment.push_str("### Non-Fibonacci Numbers\n");
        comment.push_str("The following numbers were found but are not in the Fibonacci sequence: ");
        comment.push_str(&non_fibonacci_numbers.iter()
            .map(|n| n.to_string())
            .collect::<Vec<String>>()
            .join(", "));
        comment.push_str("\n\n");
    }
    
    // Footer
    comment.push_str("---\n");
    comment.push_str("ü§ñ *This comment was automatically generated by FibBot GitHub Action*\n");
    comment.push_str("üìö *The Fibonacci sequence: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ...*\n");
    
    comment
}

/// Post a comment on a GitHub PR.
pub async fn post_comment(pr_number: u64, comment: &str, token: &str) -> Result<(), Box<dyn std::error::Error>> {
    let repo = std::env::var("GITHUB_REPOSITORY")?;
    let url = format!(
        "https://api.github.com/repos/{}/issues/{}/comments",
        repo,
        pr_number
    );
    
    println!("Posting comment to URL: {}", url);
    println!("PR number: {}", pr_number);
    println!("Repository: {}", repo);
    
    let client = Client::new();
    let comment_data = Comment { body: comment.to_string() };
    
    println!("Sending request to GitHub API...");
    let response = client
        .post(&url)
        .bearer_auth(token)
        .header("User-Agent", "fibbot-action")
        .header("Accept", "application/vnd.github.v3+json")
        .json(&comment_data)
        .send()
        .await?;
    
    if response.status().is_success() {
        println!("Successfully posted comment.");
    } else {
        let status = response.status();
        let error_text = response.text().await?;
        eprintln!("Failed to post comment: {} - {}", status, error_text);
        std::process::exit(1);  // Exit with error code to fail the workflow
    }
    
    Ok(())
}